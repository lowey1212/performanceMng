DAI Plugin Linkage Architecture (Hub-less Strategy)
===================================================
Date: 2025-09-28
Scope: All runtime DAI_* plugins (Save, Map, Spawner, Faction, Traps, SmartObject, LoadDirector, Dismember, PerfMngr, QuestManager, etc.)
Focus: Replace ad-hoc reflection “Hub” pattern with a layered, typed, low‑coupling linkage model. This document ONLY addresses linkage (service discovery, persistence integration, cross-plugin events, and dependency direction). Behavioral refactors, performance, or replication are out-of-scope for this pass.

--------------------------------------------------
1. Goals & Constraints
--------------------------------------------------
Goals:
- Keep every feature plugin loadable standalone (no hard circular dependencies).
- Provide a canonical, typed way for plugins to: (a) expose persistent state to the Save system; (b) publish and subscribe to gameplay events; (c) query other services when present.
- Eliminate per-call reflection cost & fragile string method names.
- Improve discoverability (searchable interfaces) and testability (mockable services).
- Allow late loading / disabling of non-critical plugins without crashes.

Constraints / Considerations:
- Avoid forcing a monolithic “core” runtime dependency that drags large code into minimal builds.
- Keep Blueprint ergonomics (simple GetXService functions; BP delegates remain usable).
- Migration path must remain backward compatible for one release (grace period) where feasible.

Non-Goals (this document):
- Detailed save fragment schema changes.
- Replication or networking design.
- Performance micro-optimizations.

--------------------------------------------------
2. Current State (Issues With Hub Pattern)
--------------------------------------------------
Pattern Observed: Optional soft hub using TryFindTypeSlow + ProcessEvent("RegisterService", "BroadcastEvent").
Issues:
- Reflection overhead on hot paths (fog reveals, POI events).
- Event name + payload maps are untyped; easy to mistype strings.
- Hidden dependency on method signatures in an unversioned subsystem.
- Single point risk: hub failure breaks all cross-plugin notification.
- Harder static analysis and refactoring (no clear interface contract).

--------------------------------------------------
3. Target Architecture Overview
--------------------------------------------------
Layers:
  (A) Contracts Layer (new lightweight plugin: DAI_CoreContracts)
      - Pure headers: interfaces, minimal structs, gameplay tag declarations, feature identifiers.
  (B) Service Plugins (Save, Map, Spawner, Faction, etc.)
      - Implement contracts. No cross-service hard includes except contracts.
  (C) Optional Integration Utilities
      - Blueprint libraries providing ergonomic accessors.
  (D) Messaging / Event Delivery
      - Uses Unreal's Gameplay Message Subsystem or a minimal typed dispatcher in Contracts.

Key Patterns:
  1. Service Interfaces (e.g. IDAISaveService, IDAISaveFragmentProvider, IDAIMapService, IDAISpawnService, IFactionService).
  2. Modular Feature Registration for discovery (IModularFeatures) OR on-demand subsystem enumeration.
  3. GameplayTag-based events instead of arbitrary string event names.
  4. Save Fragment Aggregation via provider interface enumeration (no manual registration calls required if using modular features; legacy optional RegisterFragmentProvider kept temporarily).

--------------------------------------------------
4. Linkage Use Cases & Solutions
--------------------------------------------------
Use Case 1: Persisting Each Plugin's State
  - Interface: IDAISaveFragmentProvider { GetFragmentId(); GetSaveFragment(); ApplySaveFragment(); }
  - Discovery:
      Option A (Preferred): Each provider registers as a Modular Feature named "DAI_SaveFragmentProvider" supplying pointer to interface implementation (usually 'this'). SaveSubsystem queries IModularFeatures::Get().GetModularFeatureImplementations() during save.
      Option B: At save time, iterate UWorldSubsystem and UGameInstanceSubsystem objects, test for interface via Cast<IDAI...>().
  - Direction: Save depends only on Contracts; providers have NO compile-time dependency on Save.

Use Case 2: Cross-Plugin Gameplay Events (e.g., Map Section Revealed -> Quest Manager listens)
  - Replace Hub with Gameplay Message Subsystem (UGameplayMessageSubsystem) or custom thin dispatcher.
  - Each event identified by FGameplayTag: DAI.Event.Map.SectionRevealed, DAI.Event.Spawner.Spawned, DAI.Event.Faction.ReputationChanged.
  - Payloads: Lightweight POD structs (e.g., FDAIMapSectionEvent { uint32 SectionId; }, FDAIPoiEvent { FGuid Handle; FVector Location; FGameplayTag Tag; }).
  - Emission: UGameplayMessageSubsystem::BroadcastMessage(EventTag, Payload).
  - Subscription: RegisterListener(EventTag, FOnMessage). BP wrappers for design convenience.
  - No dedicated global hub actor/subsystem required; leverages engine-provided system (already optimized and thread-safe for game thread usage).

Use Case 3: Accessing a Service from Another Plugin (e.g., Spawner reading Save Fragment or Faction adjusting reputations when a spawned NPC appears)
  - Access Path: World->GetSubsystem<UFactionServiceSubsystem>() or via a generic accessor in an inline helper (e.g., DAI::GetFactionService(World)).
  - For game instance scope systems (e.g., Save), use GetGameInstance()->GetSubsystem<USaveSubsystem>().
  - Provide Blueprint Library functions: GetSaveService(WorldContext), GetFactionService(WorldContext), etc., inside each plugin (these only #include their own subsystem header—no cross includes needed).
  - If a service is optional, accessor returns nullptr; callers handle soft failure gracefully.

Use Case 4: Triggering a Save After State Change
  - Provider (e.g., Map) marks itself dirty locally.
  - Periodic or event-driven: Map calls (if available) IDAISaveService::QueueSave().
  - Discovery: Inline helper that fetches USaveSubsystem (no hub). No compile dependency outside Contracts because USaveSubsystem is in Save plugin—SO: add an optional small adapter in Contracts? Instead, invert: Provide IDAISaveInvoker interface (thin) in Contracts; Save subsystem implements; Map queries for any object implementing IDAISaveInvoker via game instance subsystem enumeration.
  - Simpler Alternate: Accept a direct (non-contract) GetSubsystem include only if Save plugin is listed as an Optional dependency in .uplugin (not hard in build). If absent, compile guard macro DAI_WITH_SAVE.

Use Case 5: Deciding Startup Order / Registration
  - Minimal because subsystems auto-initialize. Modular Feature approach defers enumeration until first use.
  - Save runs a one-time RefreshProviders() after world start (FWorldDelegates::OnPostWorldInitialization) to catch world subsystems.

--------------------------------------------------
5. Recommended Concrete Patterns
--------------------------------------------------
(1) DAI_CoreContracts Plugin (New)
    Contents: Interfaces (IDAI*), event payload structs, gameplay tag header, a "DAIContractsBuild.h" with feature macros.
    .uplugin: Type=Runtime, no content, minimal dependencies ("Core", "GameplayTags").

(2) Modular Feature Names
    - "DAI_SaveFragmentProvider": For persistence fragments.
    - "DAI_Service_<ShortName>": Optional generic service registration if runtime queries needed (e.g., analytics aggregator).

(3) Event Tag Taxonomy
    Root: DAI.Event.
      DAI.Event.Save.*
      DAI.Event.Map.SectionRevealed
      DAI.Event.Map.POI.Registered
      DAI.Event.Spawner.Spawned / Despawned
      DAI.Event.Faction.ReputationChanged
    Stored in DefaultGameplayTags.ini (Contracts plugin) so all systems share canonical tags; each plugin adds depend on Contracts to resolve tags.

(4) Save Aggregation Flow
    - On QueueSave(): SaveSubsystem collects providers list (cached + dirty flag) -> for each provider call GetSaveFragment() -> embed version metadata -> compress/encrypt -> write.
    - On Load: SaveSubsystem enumerates providers again; for each fragment id found -> provider->ApplySaveFragment().
    - Provider registration changes do not require code changes in Save; new plugin just implements interface + registers modular feature.

(5) Dirty Flag Propagation
    - Each provider maintains an internal bool bDirty.
    - Provider exposes MarkDirty() (not in interface, just internal) and optionally publishes DAI.Event.Persistence.Dirty(FragmentId) for analytics.
    - SaveSubsystem can throttle autosave based on presence of any dirty provider.

(6) Blueprint Libraries
    - Each plugin supplies a static UBlueprintFunctionLibrary named <Plugin>ServicesBPLibrary with pure getters using WorldContext.
    - E.g. UDAIMapServicesBPLibrary::GetMapService(WorldContextObject) -> returns UDAIMapServiceSubsystem*.
    - No cross plugin direct function calls; only access through returned subsystem pointers or message subsystem events.

(7) Testing & Mocking
    - Contracts-only interfaces allow test modules to inject mock modular features implementing IDAISaveFragmentProvider or IDAISaveService.
    - Gameplay Message Subsystem can be unit tested by sending synthetic messages.

(8) Backward Compatibility Layer
    - Keep existing hub helpers temporarily (macro: DAI_ENABLE_LEGACY_HUB=1).
    - Each helper internally: if (Hub) { BroadcastLegacy } else { BroadcastGameplayMessage }.
    - Deprecate in release notes; remove after one release cycle.

--------------------------------------------------
6. Rationale vs Hub (Why Change)
--------------------------------------------------
| Concern              | Hub (Current)                              | Proposed Architecture                          |
|----------------------|---------------------------------------------|-----------------------------------------------|
| Type Safety          | None (string events)                        | Strong (interfaces + structs + tags)          |
| Performance          | Reflection each call                        | Direct virtual/interface + cached lookup       |
| Discoverability      | Hidden via string names                     | Greppable interface symbols                    |
| Testability          | Hard to mock central subsystem              | Swap modular feature impls in tests            |
| Failure Isolation    | Hub failure cascades                        | Each service independent                       |
| Incremental Adoption | All events funnel to hub                    | Provider-by-provider migration possible        |
| Event Filtering      | Manual string prefix checks                 | GameplayTag hierarchical queries               |
| Save Integration     | Indirect via hub broadcast                  | Direct provider enumeration                    |
| Extensibility        | Add new hub methods = runtime risk          | Add new interface extends contracts versioned  |

--------------------------------------------------
7. Implementation Phases (Linkage Only)
--------------------------------------------------
Phase 0: Preparation
  - Create DAI_CoreContracts plugin (interfaces + tag declarations + modular feature name constants).
  - Add DefaultGameplayTags.ini with event tags.

Phase 1: Persistence Unification
  - Move IDAISaveFragmentProvider definition to Contracts.
  - Implement modular feature registration in each provider subsystem Initialize(): IModularFeatures::Get().RegisterModularFeature(NAME_DAI_SaveFragmentProvider, this);
  - SaveSubsystem: On Initialize, query modular features and cache pointers (weak).

Phase 2: Event Messaging Migration
  - Introduce payload structs & message wrappers (e.g., BroadcastMapSectionRevealed(Tag, Payload)).
  - Map/Spawner/Faction emit both legacy hub and message subsystem events (dual path).
  - Consumers start listening to Gameplay Message Subsystem.

Phase 3: Service Accessors
  - Add blueprint libraries with GetXService functions (null-safe).
  - Remove direct reliance on hub for discovery.

Phase 4: Deprecation
  - Add UE_DEPRECATED macro to hub helper functions.
  - Add runtime warning one-time if hub used.

Phase 5: Cleanup
  - Remove hub code and reflection blocks (flip DAI_ENABLE_LEGACY_HUB=0 default).

--------------------------------------------------
8. Example Pseudocode Snippets
--------------------------------------------------
// Contracts: IDAISaveFragmentProvider.h
struct FDAISaveFragmentMeta { int32 SchemaVersion; FName FragmentId; };
class IDAISaveFragmentProvider { public: virtual FName GetFragmentId() const = 0; virtual int32 GetFragmentVersion() const = 0; virtual TSharedPtr<FJsonObject> Capture() const = 0; virtual bool Apply(const TSharedPtr<FJsonObject>&, int32 StoredVersion) = 0; };

// Provider (MapSubsystem Initialize)
if (!IModularFeatures::Get().IsModularFeatureRegistered(NAME_DAI_SaveFragmentProvider, this)) { IModularFeatures::Get().RegisterModularFeature(NAME_DAI_SaveFragmentProvider, this); }

// SaveSubsystem Collect
TArray<void*> RawProviders; IModularFeatures::Get().GetModularFeatureImplementations(NAME_DAI_SaveFragmentProvider, RawProviders);
for (void* Ptr : RawProviders) { if (auto* Prov = static_cast<IDAISaveFragmentProvider*>(Ptr)) Providers.Add(Prov); }

// Event Publish (Map)
FDAIMapSectionEvent Payload{SectionId}; UGameplayMessageSubsystem& Msg = UGameplayMessageSubsystem::Get(World); Msg.BroadcastMessage(TAG_DAI_Event_Map_SectionRevealed, Payload);

--------------------------------------------------
9. Risk & Mitigation
--------------------------------------------------
Risk: Modular feature misuse (double registration). Mitigation: Guard + asserts in debug.
Risk: Tag configuration drift. Mitigation: Central tag file; CI check enumerates unused vs missing tags.
Risk: Migration complexity. Mitigation: Dual-path events, deprecation macros.
Risk: Save order dependency (some provider expects another loaded first). Mitigation: Providers rely only on their own state; inter-provider ordering removed.

--------------------------------------------------
10. Minimal Changes Required per Plugin (Linkage Scope Only)
--------------------------------------------------
Each DAI_* Plugin:
  - Add Contracts dependency in .uplugin ("Optional" / no circular).
  - Implement (or adapt existing) save fragment provider interface + register modular feature.
  - Replace hub broadcasts with Gameplay Message broadcasts (retain legacy until Phase 4).
  - Add blueprint accessor library (optional but recommended for consistency).

Save Plugin:
  - Move interface / constants to Contracts.
  - Refactor SaveSubsystem to enumerate providers via modular features instead of internal registration arrays.
  - Provide helper: ForceRefreshProviders().

--------------------------------------------------
11. Summary
--------------------------------------------------
We eliminate a bespoke hub by leveraging: (1) Contracts interface plugin, (2) Modular Features for provider discovery, (3) Gameplay Message Subsystem for decoupled typed events, (4) direct subsystem getters for imperative calls. This yields better type safety, performance, modularity, and simpler future maintenance while keeping plugins independently usable. The migration path preserves compatibility during transition.

End of Document.
